:py:mod:`orbconformal.meanshift`
================================

.. py:module:: orbconformal.meanshift


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   orbconformal.meanshift.meanshift_multidim_funct_single
   orbconformal.meanshift.meanshift_multidim_funct
   orbconformal.meanshift.mode_clustering
   orbconformal.meanshift.mode_clustering_check



.. py:function:: meanshift_multidim_funct_single(X_array, current_obs, sigma, eps, maxT)

   using guassian kernel meanshift algorithm to shift a single observation
   to their mode along the kernel pseudo-density.

   :param X_array: numpy array (n, p, q), a set of multivariate functions, rows
                   correspond to new observations
   :type X_array: numpy.ndarray
   :param current_obs: numpy array (p, q), single multivariate function to move up to
                       a mode
   :type current_obs: numpy.ndarray
   :param sigma: scale for guassian kernel pseudo-density
   :type sigma: float
   :param eps: positive error bound to declare progression towards the mode complete
   :type eps: float
   :param maxT: maximum number of steps to take if eps doesn't stop the
                progression towards the mode.
   :type maxT: int

   :returns: * **t** (*int*) -- number of interations actually taken
             * **current_obs_inner** (*numpy.ndarray*) -- final step taken by the current_obs toward the mode


.. py:function:: meanshift_multidim_funct(X_array, G_array=None, sigma=1, eps=1e-05, maxT=40, parallel=1, verbose=True)

   using guassian kernel meanshift algorithm to shift a observations
   to their mode along the kernel pseudo-density.

   :param X_array: numpy array (n, p, q), a set of multivariate functions, rows
                   correspond to new observations
   :type X_array: numpy.ndarray
   :param G_array: numpy array (m, p, q), with a set of multivariate function to move
                   up to a mode (default is None, which makes it the same as X_array)
   :type G_array: numpy.ndarray
   :param sigma: scale for guassian kernel pseudo-density
   :type sigma: float
   :param eps: positive error bound to declare progression towards the mode complete
   :type eps: float
   :param maxT: int or vector of integers (m, ), the maximum number of steps to take
                if eps doesn't stop the progression towards the mode. If this is a
                vector of integers, then this is relative to each row.
   :type maxT: int or numpy.ndarray
   :param parallel: the number of cores to use to parallelize the process (across
                    rows of G_array). If parallel = 1, then no paralleization is used. Note
                    if this number is greater than the number of cores available it will
                    revert to the maximum number of cores.
   :type parallel: int
   :param verbose: if true then progress is reported with progressbar / output
   :type verbose: boolean

   :returns: * **t** (*numpy.ndarray*) -- numpy vector (m, ) of number of interations actually taken for each
               multivariate function in G_array
             * **current_obs_inner** (*numpy.ndarray*) -- numpy array (m, p, q) final step taken by the each of the individual
               multivariate fucntions in G_array toward their mode


.. py:function:: mode_clustering(X_array, sigma, eps=1e-07, maxT=50, diff_eps=1e-07, parallel=1, verbose=True)

   Find mode clusters of multivariate functional objects

   :param X_array: numpy array (r, n, p). Each row has a single representation of a
                   multivariate function in it.
   :type X_array: numpy.ndarray
   :param sigma: scale value for the distances between observations
   :type sigma: float
   :param eps: if difference between steps is less than this - treat as
               if the point has converged
   :type eps: float
   :param maxT: max number of iterations of the algorithm
   :type maxT: int
   :param diff_eps: if the final step of each of the points is within
                    this distance from each-other they will be grouped together.
   :type diff_eps: float
   :param parallel: if we should parallelize the meanshift algorithm part
   :type parallel: boolean
   :param verbose: if we should show progress
   :type verbose: boolean

   :returns: * **t** (*int*) -- integer of the number of groups there are
             * **df** (*pandas.core.frame.DataFrame*) -- DataFrame with indices of X_array's rows (in column "index") and a
               grouping index for each observation (in column "group")


.. py:function:: mode_clustering_check(X_array, sigma, eps_vec=np.array([1e-07]), maxT=50, diff_eps_vec=np.array([1e-07]), parallel=1, verbose=True)

   Inner tuning across different values of eps and diff_eps to identify the
       number of mode clusters for multivariate functional objects

   :param X_array: numpy array (r, n, p). Each row has a single representation of a
                   multivariate function in it.
   :type X_array: numpy.ndarray
   :param sigma: scale value for the distances between observations
   :type sigma: float
   :param eps_vec: numpy array (e, ) The range of eps values to look across. Where a
                   single eps value determines when to stop stepping up the psuedo-density
                   if the step before is less than eps away from the current step
                   (suggests convergence)
   :type eps_vec: numpy.ndarray
   :param maxT: max number of iterations of the meanshift algorithm
   :type maxT: int
   :param diff_eps_vec: numpy array (d, ) The range of diff_eps values to look across.
                        Where a single diff_eps value determines if the distance between a pair
                        of converged points is small enough to suggest they should be in the
                        same group
   :type diff_eps_vec: numpy.ndarray
   :param parallel: if we should parallelize the meanshift algorithm part
   :type parallel: boolean
   :param verbose: if we should show progress
   :type verbose: boolean

   :returns: a matrix (e, d) of integers of the number of mode clusters observed with
             paramters eps_vec[e] and diff_eps_vec[d]
   :rtype: numpy.ndarray



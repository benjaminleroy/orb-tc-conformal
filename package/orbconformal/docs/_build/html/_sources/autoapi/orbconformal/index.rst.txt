:py:mod:`orbconformal`
======================

.. py:module:: orbconformal


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   data_cleaning/index.rst
   distances/index.rst
   meanshift/index.rst
   utils/index.rst
   vis_tools/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   orbconformal.check_character_percent
   orbconformal.linear_interp
   orbconformal.vis_surfaces
   orbconformal.vis_sequence_surface
   orbconformal.l2_dist
   orbconformal.l2_dist_lots2one
   orbconformal.l2_dist_matrix
   orbconformal.meanshift_multidim_funct_single
   orbconformal.meanshift_multidim_funct
   orbconformal.mode_clustering
   orbconformal.mode_clustering_check



Attributes
~~~~~~~~~~

.. autoapisummary::

   orbconformal.__version__
   orbconformal._location
   orbconformal._my_file
   orbconformal.tc_rad


.. py:data:: __version__
   

   

.. py:function:: check_character_percent(x, name='x')

   check if string is a percentage (and return that as proportion if so)

   :param x: element to examine
   :type x: string
   :param name: string of name of x (assumingly this is used inside a function, that
                may not call it "x")
   :type name: string

   :returns: the proportion version of the percentage (if string was a percentage
             and meets other expectations)
   :rtype: float


.. py:function:: linear_interp(mat, na_vec)

   Linear interpolate a matrix's row values.

   :param mat: numpy array (n, p) numeric matrix with rows that need to be
               interpolated
   :type mat: numpy.ndarray
   :param na_vec: boolean numpy vector (n, ) if row should be interpolated (True)
   :type na_vec: numpy.ndarray

   :returns: updated matrix, with interpolated rows
   :rtype: numpy.ndarray

   .. rubric:: Notes

   If the beginning or end of the matrix needs to be interpolated this
   should be done outside this function.


.. py:function:: vis_surfaces(z_multi, initial_opacity=0.4, high_opacity=0.9, low_opacity=0.2)

   Create a plotly visualization of all surfaces (includes a dropdown to
   strong highlight a single curve)

   :param z_multi: numpy array (r, n, d) of 2d multivariate functions (each row is a
                   single funciton)
   :type z_multi: numpy.ndarray
   :param initial_opacity: initial opacity for all multivariate functions in the figure
   :type initial_opacity: float
   :param high_opacity: opacity for observation when the user selects that specific observation
   :type high_opacity: float
   :param low_opacity: opacity for the rest of the observations when user selects a specific
                       observation
   :type low_opacity: float

   :returns: Figure visualizing all the multivariate functions with interactive
             selector to select a single function to emphasis.
   :rtype: plotly.graph_objs._figure.Figure


.. py:function:: vis_sequence_surface(z_multi)

   Visual animation of a sequence of surfaces

   :param z_multi: numpy array (r, n, d) of 2d multivariate functions (each row is a
                   single funciton)
   :type z_multi: numpy.ndarray

   :returns: Figure visualizing the sequence of surfaces with a play button to
             move through all of them.
   :rtype: plotly.graph_objs._figure.Figure


.. py:function:: l2_dist(mat1, mat2)

   calculate l2 distance between two matrices

   :param mat1: numpy array (n, p)
   :type mat1: numpy.ndarray
   :param mat2: numpy array (n, p)
   :type mat2: numpy.ndarray

   :returns: l2 distance between matrices
   :rtype: float


.. py:function:: l2_dist_lots2one(mat1, data_array)

   calculate l2 distance between a matrix and an array of matrices

   :param mat1: numpy array (n, p)
   :type mat1: numpy.ndarray
   :param data_array: numpy array (r,n,p) treat each row (relative to first index)
                      as a new matrix
   :type data_array: numpy.ndarray

   :returns: numpy vector (r,) of l2 distances between mat1 and data_array[r]
   :rtype: numpy.ndarray


.. py:function:: l2_dist_matrix(X_array, Y_array=None)

   calculates a distance matrix between two areas of multivariate functions

   :param X_array: numpy array (r, n, p), array of multivariate functions (each row
                   is one funciton)
   :type X_array: numpy.ndarray
   :param Y_array: numpy array (t, n, p), array of multivariate functions (each row
                   is one funciton). Default is None (if so, then X_array is used)
   :type Y_array: numpy.ndarray

   :returns: numpy array (r, t) of distances between X_array[r] and Y_array[t]
   :rtype: numpy.ndarray


.. py:function:: meanshift_multidim_funct_single(X_array, current_obs, sigma, eps, maxT)

   using guassian kernel meanshift algorithm to shift a single observation
   to their mode along the kernel pseudo-density.

   :param X_array: numpy array (n, p, q), a set of multivariate functions, rows
                   correspond to new observations
   :type X_array: numpy.ndarray
   :param current_obs: numpy array (p, q), single multivariate function to move up to
                       a mode
   :type current_obs: numpy.ndarray
   :param sigma: scale for guassian kernel pseudo-density
   :type sigma: float
   :param eps: positive error bound to declare progression towards the mode complete
   :type eps: float
   :param maxT: maximum number of steps to take if eps doesn't stop the
                progression towards the mode.
   :type maxT: int

   :returns: * **t** (*int*) -- number of interations actually taken
             * **current_obs_inner** (*numpy.ndarray*) -- final step taken by the current_obs toward the mode


.. py:function:: meanshift_multidim_funct(X_array, G_array=None, sigma=1, eps=1e-05, maxT=40, parallel=1, verbose=True)

   using guassian kernel meanshift algorithm to shift a observations
   to their mode along the kernel pseudo-density.

   :param X_array: numpy array (n, p, q), a set of multivariate functions, rows
                   correspond to new observations
   :type X_array: numpy.ndarray
   :param G_array: numpy array (m, p, q), with a set of multivariate function to move
                   up to a mode (default is None, which makes it the same as X_array)
   :type G_array: numpy.ndarray
   :param sigma: scale for guassian kernel pseudo-density
   :type sigma: float
   :param eps: positive error bound to declare progression towards the mode complete
   :type eps: float
   :param maxT: int or vector of integers (m, ), the maximum number of steps to take
                if eps doesn't stop the progression towards the mode. If this is a
                vector of integers, then this is relative to each row.
   :type maxT: int or numpy.ndarray
   :param parallel: the number of cores to use to parallelize the process (across
                    rows of G_array). If parallel = 1, then no paralleization is used. Note
                    if this number is greater than the number of cores available it will
                    revert to the maximum number of cores.
   :type parallel: int
   :param verbose: if true then progress is reported with progressbar / output
   :type verbose: boolean

   :returns: * **t** (*numpy.ndarray*) -- numpy vector (m, ) of number of interations actually taken for each
               multivariate function in G_array
             * **current_obs_inner** (*numpy.ndarray*) -- numpy array (m, p, q) final step taken by the each of the individual
               multivariate fucntions in G_array toward their mode


.. py:function:: mode_clustering(X_array, sigma, eps=1e-07, maxT=50, diff_eps=1e-07, parallel=1, verbose=True)

   Find mode clusters of multivariate functional objects

   :param X_array: numpy array (r, n, p). Each row has a single representation of a
                   multivariate function in it.
   :type X_array: numpy.ndarray
   :param sigma: scale value for the distances between observations
   :type sigma: float
   :param eps: if difference between steps is less than this - treat as
               if the point has converged
   :type eps: float
   :param maxT: max number of iterations of the algorithm
   :type maxT: int
   :param diff_eps: if the final step of each of the points is within
                    this distance from each-other they will be grouped together.
   :type diff_eps: float
   :param parallel: if we should parallelize the meanshift algorithm part
   :type parallel: boolean
   :param verbose: if we should show progress
   :type verbose: boolean

   :returns: * **t** (*int*) -- integer of the number of groups there are
             * **df** (*pandas.core.frame.DataFrame*) -- DataFrame with indices of X_array's rows (in column "index") and a
               grouping index for each observation (in column "group")


.. py:function:: mode_clustering_check(X_array, sigma, eps_vec=np.array([1e-07]), maxT=50, diff_eps_vec=np.array([1e-07]), parallel=1, verbose=True)

   Inner tuning across different values of eps and diff_eps to identify the
       number of mode clusters for multivariate functional objects

   :param X_array: numpy array (r, n, p). Each row has a single representation of a
                   multivariate function in it.
   :type X_array: numpy.ndarray
   :param sigma: scale value for the distances between observations
   :type sigma: float
   :param eps_vec: numpy array (e, ) The range of eps values to look across. Where a
                   single eps value determines when to stop stepping up the psuedo-density
                   if the step before is less than eps away from the current step
                   (suggests convergence)
   :type eps_vec: numpy.ndarray
   :param maxT: max number of iterations of the meanshift algorithm
   :type maxT: int
   :param diff_eps_vec: numpy array (d, ) The range of diff_eps values to look across.
                        Where a single diff_eps value determines if the distance between a pair
                        of converged points is small enough to suggest they should be in the
                        same group
   :type diff_eps_vec: numpy.ndarray
   :param parallel: if we should parallelize the meanshift algorithm part
   :type parallel: boolean
   :param verbose: if we should show progress
   :type verbose: boolean

   :returns: a matrix (e, d) of integers of the number of mode clusters observed with
             paramters eps_vec[e] and diff_eps_vec[d]
   :rtype: numpy.ndarray


.. py:data:: _location
   

   

.. py:data:: _my_file
   

   

.. py:data:: tc_rad
   

   

